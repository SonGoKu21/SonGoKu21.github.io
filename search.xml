<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blockchain attack method</title>
      <link href="/2020/12/22/blockchain-attack-method/"/>
      <url>/2020/12/22/blockchain-attack-method/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链常见的攻击手段"><a href="#区块链常见的攻击手段" class="headerlink" title="区块链常见的攻击手段"></a>区块链常见的攻击手段</h1><h2 id="Front-Running-Attacks"><a href="#Front-Running-Attacks" class="headerlink" title="Front-Running Attacks"></a>Front-Running Attacks</h2><h3 id="提前攻击定义"><a href="#提前攻击定义" class="headerlink" title="提前攻击定义"></a>提前攻击定义</h3><p>提前攻击是，当恶意节点观察到一个交易传播之后，但是在完成之前，尝试让自己的交易确认在观察到的交易之前或者替代观察到的交易。</p><h3 id="传统的提前攻击"><a href="#传统的提前攻击" class="headerlink" title="传统的提前攻击"></a>传统的提前攻击</h3><p>主要分为两类</p><p>（1）地面交易者偷听到经纪人和他的客户就大额交易的协商之后，超过经纪人提前购买，当大额购买导致暂时减少股票供应时可能会获利。</p><p>（2）或者，恶意的经纪人可能会在收到客户的购买指令和实际执行购买期间，通过购买自己的股票来抢占自己客户的订单。（类似的技术可以应用在大额交易）。</p><h3 id="Front-Running-attack、insider-trading-and-arbitrage"><a href="#Front-Running-attack、insider-trading-and-arbitrage" class="headerlink" title="Front-Running attack、insider trading and arbitrage"></a>Front-Running attack、insider trading and arbitrage</h3><p>Front-Running attack 提前攻击：有人观察到一个具体的交易被设置为执行并在实际执行之前对其作出反应。</p><p>Insider trading 内幕攻击：如果此人可以访问通常的特权信息，这些信息可以用来预测未来的交易，但是不会对实际的未决定的交易作出反应，就认为这种攻击是内幕攻击</p><p>arbitrage 套利攻击：如果此人在交易完成之后，或者信息是公开的时候作出反应。并且以很快的反应获利，这被认为是套利。</p><h2 id="A-Taxonomy-of-Front-Running-Attacks"><a href="#A-Taxonomy-of-Front-Running-Attacks" class="headerlink" title="A Taxonomy of Front-Running Attacks"></a>A Taxonomy of Front-Running Attacks</h2><p>我们将他分为三类：替换、插入和压制攻击。</p><p>对于三类攻击，Alice 尝试去调用处于特定状态的智能合约上的函数，Mallory尝试在Alice调用在相同状态下的智能合约上的她自己的函数。</p><p>替换攻击 displacement attack：对攻击者来说，Alice的函数调用运行在Mallory之后并不重要。Alice的函数可以成为孤儿的，或者是没有任何含义的。替换的例子包括：Alice试图注册一个域名，Mallory先注册它[35]；Alice试图提交一个bug以获得赏金，Mallory窃取并首先提交[16]；Alice试图在拍卖中提交出价，然后Mallory复制它。</p><p>插入攻击 insertion attack，在Mallory运行她的函数之后，智能合约的状态改变并且她需要Alice原始的函数运行在这个修改后的状态。举个例子，如果Alice以高于最佳报价的价格向区块链资产下订单，Mallory将插入两个交易：她将以最佳报价购买，然后以Alice稍高的购买价格提供相同的资产出售。如果Alice在随后执行，Mallory将从价差中获利，而不必持有资产。</p><p>压制攻击，suppression attack，在Mallory运行她的函数之后，她试图延迟Alice运行她的函数。在延迟之后，她对Alice的功能是否运行无所谓。</p><p>这些攻击都有两个变量，异步和散装</p><h2 id="Cases-of-Front-Running-in-DApps-decentral-applications"><a href="#Cases-of-Front-Running-in-DApps-decentral-applications" class="headerlink" title="Cases of Front-Running in DApps(decentral applications)"></a>Cases of Front-Running in DApps(decentral applications)</h2><p>Markets and Exchanges</p><p>Crypto-Collectibles Games</p><p>Gambling   GAS Auction</p><p>Name Services</p><h2 id="Cases-of-Front-Running-in-ICOs"><a href="#Cases-of-Front-Running-in-ICOs" class="headerlink" title="Cases of Front-Running in ICOs"></a>Cases of Front-Running in ICOs</h2><p>初始代币发售</p><h2 id="Key-Mitigations"><a href="#Key-Mitigations" class="headerlink" title="Key Mitigations"></a>Key Mitigations</h2><p>分为三类</p><p>（1）区块链移除旷工随意改变交易顺序或者强制排序的能力</p><p>（2）密码学技术来限制交易的能见度，给潜在的提前攻击很少的信息</p><p>（3）DApps自下而上的设计来移除他们的操作中交易顺序和时间的重要性。</p><h3 id="Transaction-Sequencing"><a href="#Transaction-Sequencing" class="headerlink" title="Transaction Sequencing"></a>Transaction Sequencing</h3><p>FIFO在分布式的网络中是不太可能的，</p><p>矿工倾向于优先打包高汽油费和或者高nonce的交易</p><p>Canonical Transaction Ordering Rule (CTOR)，词典顺序排序，适用于比特币，但是不适用于以太坊</p><h3 id="Confidentiality"><a href="#Confidentiality" class="headerlink" title="Confidentiality"></a>Confidentiality</h3><p>现在的一个保护隐私的研究方向就是DApps。</p><p>DApp交互包括以下组件</p><p>（1）DApp的代码，（2）DApp的当前状态，（3）被调用的函数的名称，（4）提供给该函数的参数，（5）该函数的合约地址 （6）发送者的身份。<br>   应用于DApp的机密性可能意味着对每一项的不同保护级别。 对于前端运行，函数调用（3,4）是最重要的，但是，可以从状态更改（2）推断出函数调用。  Hawk [38]和Ekiden [21]是（2，3，4）机密性的示例（有局限性，我们正在讨论）。</p><p>传统的预防提前攻击的方法，dark pool</p><p><strong>Commit/Reveal</strong>   </p><p><img src="1.png" alt="Commit/Reveal"></p><p>Commit and Reveal. User sends a commitment transaction with the hash of the data, After the commitment period is over, user sends her reveal transaction to the DApp revealing the information that matches the commitment</p><p><strong>Commit/Reveal</strong> 是一个  two-round protocol，如果在第一轮的时候被抛弃的话将会成为一个很大的问题。举个例子，在金融交易中其他交易顺序是在可预测的间隔里的，攻击者通过观察可以标记具有多个已经提交的交易的序列（价格-时间优先排序），不执行交易。他们只会揭开那些对他们有利的交易。 最后，我们注意到任何多轮协议都将带来可用性挑战：用户必须意识到，参与第一轮不足以完成其意图。</p><p>Enhanced Commit/Reveal**</p><p><img src="2.png" alt="Enhanced Commit/Reveal"></p><p>Fig. 7. Submarine Send [18]. User generates an Unlock transaction from which the commitment address is retrieved using ECDSA ECRecover. 1. by funding the commitment address, user is committed to the transaction. 2. User sends the reveal transaction to the DApp, revealing the nature of the commitment transaction. 3. She broadcasts the unlock transaction to unlock the funds in the commitment address. 4. After the “Auction” is over, anyone can call Finalize function to finalize the process.</p><p>这个协议增加了一个commitment address，为commitment address提供资金，用户承诺了交易。</p><h2 id="Reentrancy"><a href="#Reentrancy" class="headerlink" title="Reentrancy"></a>Reentrancy</h2><p>重入攻击</p><h3 id="Reentrancy-on-a-single-function"><a href="#Reentrancy-on-a-single-function" class="headerlink" title="Reentrancy on a single function"></a>Reentrancy on a single function</h3><p>THE DAO攻击</p><p>第一种bug是指涉及在第一个函数调用完成之前，可以重复调用此函数。</p><pre class="line-numbers language-solidity"><code class="language-solidity">// INSECUREmapping (address => uint) private userBalances;function withdrawBalance() public {    uint amountToWithdraw = userBalances[msg.sender];    (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); // At this point, the caller's code is executed, and can call withdrawBalance again    require(success);    userBalances[msg.sender] = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为直到函数的最后之前，用户的余额都没有置为0，后续的函数调用依旧是成功的，并且一遍又一遍的在退还余额。</p><p>在这个给定的例子中，最好去防止这种攻击的方法是确保直到你完成你需要做的内部事务之前，不要去调用一个外部的函数。</p><pre><code>mapping (address =&gt; uint) private userBalances;function withdrawBalance() public {    uint amountToWithdraw = userBalances[msg.sender];    userBalances[msg.sender] = 0;    (bool success, ) = msg.sender.call.value(amountToWithdraw)(&quot;&quot;); // The user&#39;s balance is already 0, so future invocations won&#39;t withdraw anything    require(success);}</code></pre><p>Cross-function Reentrancy</p><p>交叉函数重入攻击</p><p>攻击者可以使用不同的共享同样状态的函数来做同样的攻击。</p><pre><code>// INSECUREmapping (address =&gt; uint) private userBalances;function transfer(address to, uint amount) {    if (userBalances[msg.sender] &gt;= amount) {       userBalances[to] += amount;       userBalances[msg.sender] -= amount;    }}function withdrawBalance() public {    uint amountToWithdraw = userBalances[msg.sender];    (bool success, ) = msg.sender.call.value(amountToWithdraw)(&quot;&quot;); // At this point, the caller&#39;s code is executed, and can call transfer()    require(success);    userBalances[msg.sender] = 0;}</code></pre><p>在这种情况下，攻击者在withdrawBalance中的外部调用上执行其代码时，将调用transfer（）。 由于其余额尚未设置为0，因此即使他们已经收到提款，他们也可以转移代币。 DAO攻击中也使用了此漏洞。</p><p>相同的解决方案将起作用，并具有相同的警告。 另请注意，在此示例中，两个功能都是同一合约的一部分。 但是，如果多个合约共享状态，则可能会在多个合约中发生同一错误。</p><h3 id="Pitfalls-in-Reentrancy-Solutions"><a href="#Pitfalls-in-Reentrancy-Solutions" class="headerlink" title="Pitfalls in Reentrancy Solutions"></a>Pitfalls in Reentrancy Solutions</h3><p>重入攻击解决方案中的陷阱</p><p>因此重入攻击可以发生在多个交叉函数，甚至多个合约之中，解决单个函数的方法难以奏效。</p><p>相反，我们建议您先完成所有内部工作（即状态更改），然后再调用外部函数。 如果仔细遵守此规则，将可以避免由于重新进入而引起的漏洞。 但是，您不仅需要避免过早地调用外部函数，还需要避免调用会调用外部函数的函数。 例如，以下内容是不安全的：</p><pre><code>// INSECUREmapping (address =&gt; uint) private userBalances;mapping (address =&gt; bool) private claimedBonus;mapping (address =&gt; uint) private rewardsForA;function withdrawReward(address recipient) public {    uint amountToWithdraw = rewardsForA[recipient];    rewardsForA[recipient] = 0;    (bool success, ) = recipient.call.value(amountToWithdraw)(&quot;&quot;);    require(success);}function getFirstWithdrawalBonus(address recipient) public {    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once    rewardsForA[recipient] += 100;    withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.    claimedBonus[recipient] = true;}</code></pre><pre><code>mapping (address =&gt; uint) private userBalances;mapping (address =&gt; bool) private claimedBonus;mapping (address =&gt; uint) private rewardsForA;function untrustedWithdrawReward(address recipient) public {    uint amountToWithdraw = rewardsForA[recipient];    rewardsForA[recipient] = 0;    (bool success, ) = recipient.call.value(amountToWithdraw)(&quot;&quot;);    require(success);}function untrustedGetFirstWithdrawalBonus(address recipient) public {    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once    claimedBonus[recipient] = true;    rewardsForA[recipient] += 100;    untrustedWithdrawReward(recipient); // claimedBonus has been set to true, so reentry is impossible}</code></pre><p>另外一个方法是 mutex（互斥），这使您可以“锁定”某些状态，因此只能由锁的所有者更改。 一个简单的例子可能看起来像</p><pre><code>// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared statemapping (address =&gt; uint) private balances;bool private lockBalances;function deposit() payable public returns (bool) {    require(!lockBalances);    lockBalances = true;    balances[msg.sender] += msg.value;    lockBalances = false;    return true;}function withdraw(uint amount) payable public returns (bool) {    require(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);    lockBalances = true;    (bool success, ) = msg.sender.call(amount)(&quot;&quot;);    if (success) { // Normally insecure, but the mutex saves it      balances[msg.sender] -= amount;    }    lockBalances = false;    return true;}</code></pre><p>互斥锁</p><h2 id="DoS-with-Unexpected-revert"><a href="#DoS-with-Unexpected-revert" class="headerlink" title="DoS with (Unexpected) revert"></a>DoS with (Unexpected) revert</h2><p>具有意外还原的拒绝服务攻击</p><pre><code>// INSECUREcontract Auction {    address currentLeader;    uint highestBid;    function bid() payable {        require(msg.value &gt; highestBid);        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert        currentLeader = msg.sender;        highestBid = msg.value;    }}</code></pre><p>如果攻击者使用具有回退所有付款功能的后备功能的智能合约出价，则攻击者可以赢得任何拍卖。 当它尝试退款给旧的领导者时，如果退款失败，它将还原。 这意味着恶意的竞标者可以成为领导者，同时确保对他们地址的任何退款都将始终失败。 这样，它们可以防止其他任何人调用bid（）函数，并永远保持领导者地位。 如前所述，建议改为建立预付款系统。<br>    另一个示例是合同可以遍历数组以向用户（例如，众筹合同中的支持者）付款的情况。 通常要确保每次付款都能成功。 如果没有，应该还原。 问题是，如果一个呼叫失败，您将还原整个支付系统，这意味着循环将永远无法完成。 没有人得到报酬，因为一个地址强迫发生错误。</p><pre><code>address[] private refundAddresses;mapping (address =&gt; uint) public refunds;// badfunction refundAll() public {    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated        require(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds    }}</code></pre><h2 id="DoS-with-Block-Gas-Limit"><a href="#DoS-with-Block-Gas-Limit" class="headerlink" title="DoS with Block Gas Limit"></a>DoS with Block Gas Limit</h2><p>区块汽油费限制的拒绝服务攻击</p><p>每个模块在花费的汽油费以及可完成的汽油费上都有一个上限。 这就是区块汽油费限制。 如果花费的汽油费超过此限制，则交易将失败。 这导致了两种可能的拒绝服务媒介：</p><h3 id="Gas-Limit-DoS-on-a-Contract-via-Unbounded-Operations"><a href="#Gas-Limit-DoS-on-a-Contract-via-Unbounded-Operations" class="headerlink" title="Gas Limit DoS on a Contract via Unbounded Operations"></a>Gas Limit DoS on a Contract via Unbounded Operations</h3><p>即使没有故意攻击，这也可能导致问题。 但是，如果攻击者可以操纵所需的汽油费，那就尤其糟糕。 在前面的示例中，攻击者可以添加一堆地址，每个地址都需要获得非常小的退款。 因此，退还每个攻击者地址的汽油成本最终可能超过气体限制，从而完全阻止了退款交易的发生。</p><h3 id="Gas-Limit-DoS-on-the-Network-via-Block-Stuffing"><a href="#Gas-Limit-DoS-on-the-Network-via-Block-Stuffing" class="headerlink" title="Gas Limit DoS on the Network via Block Stuffing"></a>Gas Limit DoS on the Network via Block Stuffing</h3><p>即使您的合同不包含无限循环，攻击者也可以通过放置具有足够高的汽油费的计算密集型交易，来阻止其他交易包含在区块链的多个区块中。<br>    为此，攻击者可以发出多个交易，这些交易将消耗整个瓦斯限额，并在开采下一个区块后立即包含足够高的瓦斯价格。 没有汽油价格可以保证将其包含在区块中，但是价格越高，机会就越大。<br>    如果攻击成功，则该块中将不包含其他任何事务。 有时，攻击者的目标是在特定时间之前阻止特定合同的交易。<br>    该攻击是在赌博应用Fomo3D上进行的。 该应用程序旨在奖励最后购买“钥匙”的地址。 每次购买钥匙都会延长计时器的时间，一旦计时器变为0，游戏便结束了。攻击者购买了一把钥匙，然后连续塞满13个区块，直到触发计时器并释放了支出。 攻击者在每个区块上发送的交易占用了790万个gas，因此该gas限制允许进行一些小的“发送”交易（每个交易具有21,000个gas），但是不允许对buyKey（）函数的任何调用（花费300,000+ gas）。<br>    可以在需要在特定时间段内采取行动的任何合同上使用“块填充”攻击。 但是，与任何攻击一样，它只有在预期的回报超过其成本时才有利可图。 这种攻击的成本与需要填充的块数成正比。 如果可以通过阻止其他参与者采取行动来获得丰厚的回报，那么这种攻击很可能会将您的合同作为攻击目标。</p><h2 id="Insufficient-gas-griefing"><a href="#Insufficient-gas-griefing" class="headerlink" title="Insufficient gas griefing"></a>Insufficient gas griefing</h2><p>汽油费不足</p><p>接受通用数据并使用它通过低级address.call（）函数调用另一个合约（“子调用”）的合约可能会发生这种攻击，这在多重签名和交易中继智能合约</p><p>如果调用失败，则合同有两个选择：</p><p>1.恢复整个交易</p><p>2.继续执行。</p><p>以简化中继器合同的以下示例为例，无论子调用的结果如何，该合同都将继续执行：</p><pre><code>contract Relayer {    mapping (bytes =&gt; bool) executed;    function relay(bytes _data) public {        // replay protection; do not call the same transaction twice        require(executed[_data] == 0, &quot;Duplicate call&quot;);        executed[_data] = true;        innerContract.call(bytes4(keccak256(&quot;execute(bytes)&quot;)), _data);    }}</code></pre><p>该合同允许交易中继。 想要进行交易但无法自己执行交易的人（例如，由于缺乏以太坊支付汽油费）可以签署他想通过的数据，并在任何介质上以其签名传输数据。 然后，第三方“转发者”可以代表用户将该交易提交给网络。<br>    如果仅给定适量的气体，则中继器将完成执行，将_dataargument记录在已执行的映射中，但是子调用将失败，因为它收到的汽油费不足以完成执行。_</p><p>攻击者可以使用它来检查事务，通过向它们发送少量汽油费来使它们失败。 这种攻击是“griefing”的一种形式：它不会直接使攻击者受益，反而会给受害者带来伤害。 如果他们是第一个将其提交给Relayer的人，那么一个愿意持续消耗少量汽油费的专门攻击者理论上可以以此方式审查所有交易。 解决此问题的一种方法是实施要求转发器提供足够的气体以完成子呼叫的逻辑。 如果矿工试图在这种情况下进行攻击，则require语句将失败，内部调用将恢复。 用户可以指定最小gasLimit以及其他数据（在此示例中，通常_gasLimit值将通过签名进行验证，但在这种情况下为简单起见将其省略）。</p><pre><code>// contract called by Relayercontract Executor {    function execute(bytes _data, uint _gasLimit) {        require(gasleft() &gt;= _gasLimit);        ...    }}</code></pre><p>另外一个解决的办法是只允许信任的用户来中继交易</p><h2 id="Forcibly-Sending-Ether-to-a-Contract"><a href="#Forcibly-Sending-Ether-to-a-Contract" class="headerlink" title="Forcibly Sending Ether to a Contract"></a>Forcibly Sending Ether to a Contract</h2><p>强制向合同发送以太币</p><p>引用：<a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/" target="_blank" rel="noopener">https://consensys.github.io/smart-contract-best-practices/known_attacks/</a></p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly_12/13</title>
      <link href="/2020/12/13/weekly-12-13/"/>
      <url>/2020/12/13/weekly-12-13/</url>
      
        <content type="html"><![CDATA[<h1 id="联邦学习入门（Federated-Learning）"><a href="#联邦学习入门（Federated-Learning）" class="headerlink" title="联邦学习入门（Federated Learning）"></a>联邦学习入门（Federated Learning）</h1><p>联邦学习算是我接触到的一个比较新的方向，由于各种莫名其妙的原因，在大学的时候一直抵触接触Machine Learning、Deep Learning。所以在上一周（摸鱼中）看了很多吴恩达老师的视频进行学习，不过总时长也太长了，很怀疑自己有没有耐心看下去。这一周先从Federated Learning的白皮书看起。</p><h2 id="Communication-Efficient-Learning-of-Deep-Networks-from-Decentralized-Data"><a href="#Communication-Efficient-Learning-of-Deep-Networks-from-Decentralized-Data" class="headerlink" title="Communication-Efficient Learning of Deep Networks from Decentralized Data"></a>Communication-Efficient Learning of Deep Networks from Decentralized Data</h2><p>这篇文章是2016年由谷歌实验室提出的，联邦学习算是分布式学习的一种，</p><p>首先看看他的摘要</p><p><strong>Abstract</strong></p><p>现代移动设备可以访问适合于学习模型的大量数据，从而可以极大地改善设备上的用户体验。 例如，语言模型可以改善语音识别和文本输入，图像模型可以自动选择优质照片。<br>   但是，这种丰富的数据通常对隐私敏感，数量大或两者兼而有之，这可能会阻止登录到数据中心并使用常规方法进行培训。 我们提倡一种替代方法，将训练数据保留在移动设备上，并通过汇总本地计算的更新来学习共享模型。 我们将这种分散式方法称为联邦学习。<br>   我们提出了一种基于迭代模型平均的深度网络联合学习的实用方法，并考虑了五个不同的模型架构和四个数据集，进行了广泛的经验评估。 这些实验表明，该方法对于不平衡和非IID（独立同分布）数据分布是稳健的，该分布是此设置的定义特征。 通信成本是主要的约束条件，与同步随机梯度下降相比，我们显示要求的通信回合减少了10–100。</p><p>通过文章中的总结，联邦优化有以下几个关键的属性：</p><p>$\bullet$  Non-IID( Non-independent and identically distributed )：分散各个设备端的数据集因为用户的特异性而存在较大的差异；</p><p>$\bullet$  Unbalanced：因为用户对于服务端的访问频率差异，使得各个设备端训练数据量存在不同；</p><p>$\bullet$  Massively distributed：设备端数量远远大于设备端训练模型的数量；</p><p>$\bullet$  Limited communication：因为网络等原因，使得设备端访问连接受到限制</p><p>只选择一部分的client来提高效率，实验表明，挑选超过特定值的client数量会降低效率。然后，每个选定的client基于全局状态和本地的数据库执行本地的计算，并且发送更新给服务器。</p><p>当我们关注非凸神经网络目标是，我们考虑的算法适用于以下形式的任何有限和的目标。</p><p>$\min_{w\in \mathbb{R}^d} f(w)$ 其中$f(w)\overset{def}{=} \frac{1}{n}\sum^{n}_{i=1}f_i(w) $。</p><p>对于一个机器学习的问题，我们通常会设置$f_i(w)= \ell(x_i,y_i,w) $，即样本数据$(x_i.y_i)$以及参数$w$。假设有$K$个用户数据分区，那么用$P_k$表示$k$用户的数据点索引的集合，令$n_k=|P_{k}|$，因此，上述的模型可以表示为</p><p>$f(w)=\sum_{k=1}^{K} \frac{n_k}{n}F_k(w) x$其中，$F_k(w)=\frac{1}{n_k}\sum_{i\in P_{k}}f_i(w)$  </p><p>因为$F_k(w)$是IID（独立同分布）。那么显然：<br>$$<br>E_{P_k}[F_k(w)]=f(w)<br>$$<br>独立同分布假设通常通过由分布式优化算法得出；</p><h2 id="联邦平均算法"><a href="#联邦平均算法" class="headerlink" title="联邦平均算法"></a>联邦平均算法</h2><p>近年来，深度学习的大量成功应用几乎完全依赖于随机梯度下降（SGD）的变体来进行优化； 实际上，许多进步可以理解为通过简单的基于梯度的方法使模型的结构（以及损失函数）更易于优化[16]。所以，自然而然的，我们从建立从SGD开始的联邦优化算法。</p><p>SGD可以简单的应用于联邦优化问题，在此问题中，每轮通信都执行一次批次梯度计算（例如在随机选择的client上）。这种方法的计算效率很高，但需要进行大量轮训才能生成好的模型（例如，即使使用批量归一化等高级方法，Ioffe和Szegedy [21]训练的MNIST在大小为60的小型批次上也可以进行50000步）。 我们在CIFAR-10实验中考虑了这个基线。</p><p>在联邦环境中，挂钟时间花费很少的钱来吸引更多的客户，因此对于我们的基线，我们使用大批量同步SGD；  Chen等人的实验。[8]展示了这种方法在数据中心环境中是最新技术，其性能优于异步方法。 为了在联邦环境中应用此方法，我们在每个回合中选择一个client分区，然后计算这些client所拥有的所有数据的损失梯度。 因此，C控制全局批处理大小，其中C = 1对应于全批（非随机）梯度下降。2我们将此基准算法称为FederatedSGD（或FedSGD）。</p><p>一个典型的具有$C=1$并且固定的学习率$\eta$的$FedSGD$实现是每个client计算$g_k =\nabla F_k(w_t)$，本地数据在当前模型$w_t$的平均梯度，中央服务器聚合这些梯度并应用更新$w_{t+1}\leftarrow w_t \leftarrow \eta \sum_{k=1}^K \frac{n_k}{n}g_k$,因为$\sum_{k=1}^K \frac{n_k}{n}g_k=\nabla f(w_t)$。等效更新为$\forall k,w_{i+1}^k \leftarrow w_t \leftarrow \eta g_k ,$然后$w_{t+1}\leftarrow \sum_{k=1}^K \frac{n_k}{n}w_{t+1}^k.$也就是说，每个client使用其本地数据在本地对当前模型进行梯度下降的一步，然后服务器对所得模型进行加权平均。一旦以这种方式编写了算法，我们就可以通过在平均步骤之前多次迭代本地更新$w^k\leftarrow w^k \leftarrow \eta\nabla F_k(w^k)$来为每个client添加更多计算。我们称这种方法为FederatedAveraging（或FedAvg）。计算量受到三个关键参数的控制，$C$,每轮执行计算的client的比例。$E$,每个client在每个回合中对其本地数据集进行的训练的次数。$B$，用于client更新的本地最小batch大小。我们写$B=\infin$表示整个本地数据集被视为单个小batch。因此，因此，在该算法族的一个端点，我们可以取$B = \infin$和$E = 1$，这恰好对应于$FedSGD$.对于有$n_k$个本地样本的client，每轮本地更新的数量由$u_k=E\frac{n_k}{B}$给出。在算法1中给出了完整的伪代码</p><p>对于一般的非凸目标，参数空间中的平均模型可能会产生任意不良的模型。</p><p><img src="1.png" alt="Loss function"></p><p><img src="2.png" alt="Algorithm"></p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Federated Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weekly11/28</title>
      <link href="/2020/11/28/weekly11-28/"/>
      <url>/2020/11/28/weekly11-28/</url>
      
        <content type="html"><![CDATA[<h1 id="一周工作总结-（2020-11-23-11-29）"><a href="#一周工作总结-（2020-11-23-11-29）" class="headerlink" title="一周工作总结 （2020/11/23~11/29）"></a>一周工作总结 （2020/11/23~11/29）</h1><p>这周主要看了几篇DP和Game theory的文章</p><p>（1）Personalized Location Privacy Protection for Location-Based Services in Vehicular Networks</p><p>（2）Sensitivity Analysis for Non-Interactive Differential Privacy: Bounds and Efficient Algorithms</p><p>（3）A Trust-Grained Personalized Privacy-Preserving Scheme for Big Social</p><h2 id="一-车载网络中基于位置服务的个性化位置隐私保护"><a href="#一-车载网络中基于位置服务的个性化位置隐私保护" class="headerlink" title="一 车载网络中基于位置服务的个性化位置隐私保护"></a>一 车载网络中基于位置服务的个性化位置隐私保护</h2><p>Abstract—With the development of vehicular network, location-based services (LBSs) provide increasing diversified services for drivers and passengers. When users enjoy the services, users’ location needs to be constantly updated to service providers, which causes the location information to be speculated and attacked by attackers. However, existing schemes don’t provide differentiated protection for users’ different locations, which may lead to the leakage of location information. Therefore, we propose a location privacy protection method to satisfy users’ personalized privacy needs with reasonable protection of their privacy. Firstly, we define a normalized decision matrix to describe the efficiency and privacy effects of a route, and establish a multi-attribute utility function to quantify the utility of different routes for route selection. Then, according to users’ personalized privacy protection need, we allocate the privacy budget for each query location on the selected route based on the distance between it and his nearest sensitive location. Experimental results demonstrate that compared to existing methods, our scheme can meet the user’s service requirements and achieve better service quality under the conditions of reasonable protection of their privacy.</p><p>关键词：Personalized differential privacy, privacy budget allocation, the optimal route, quality of service.</p><p>个性化差分隐私、隐私预算分配、最佳路径、服务质量</p><p>位置差分隐私 Location Differential Privacy</p><p><img src="1.png" alt="1"></p><p>其中车辆用户的位置在A，目的地是E，敏感位置F，H，I。</p><p><img src="2.png" alt="2"></p><p>（1）Route Selection<br>$$<br>d_{k1}^o= \begin{matrix} \sum_{i=1}^n \sqrt{(x_{i+1}^k-x_{i}^k)^2+(y_{i+1}^k-y_i^k)^2} \end{matrix}<br>\<br>d_{k2}^s = \sum^{n.N}_{i,j=1} \lambda d_{ij}^k<br>$$<br>多属性理论，第一个属性用$d_{k1}^o$表示第$k_{th}$路径的总长度，第二个属性用$d_{k2}^s$表示第$k$ 条路径上的所有查询位置与其最近的敏感位置之间的距离之和。</p><p>影响用户选择的属性集表示为$\{ d_{k1}^o,d_{k2}^s \}$。然后对他们进行归一化：<br>$$ r_{k1}=\frac{ max\{{ d_{k1}^o }\}-d_{ k1 }^o }{ max\{d_{k1}^o \}-min\{ d_{k1}^o \}}\\r_{k2}=\frac{ max\{{ d_{k2}^s }\}-d_{ k2 }^s }{ max\{d_{k2}^s \}-min\{ d_{k2}^s \}}$$ <br>用户的路径效用：<br>$$<br>z_i = w_1r_{i1}+w_2r_{i2}<br>$$<br>使用信息熵来得到相关的权重：<br>$$<br>w_j = \frac{\lambda_jd_j}{\lambda_1d_1+\lambda_2d_2}j=1,2,<br>$$<br>其中$\lambda_j$是用户对于一个确定属性的偏好。</p><p>（2）Personalize Privacy Budget Allocation</p><p>method 1：保护在敏感圈外的位置</p><p>method 2：保护在敏感圈内的位置</p><p>敏感圈半径$r$：基于地理位置不可分。用户的真实位置与扰动位置之间的距离表示如下：<br>$$<br>rr = \frac{-1}{\epsilon_i}(W_{-1}(\frac{Z-1}{\epsilon})+1)z = rand(0,1)<br>$$<br>其中，z表示概率的选择。如果用户将真实位置和扰动位置之间的距离的可接受误差设置为$\Delta$，则应满足$rr&lt;\Delta$。所以敏感度圆的半径$r$为<br>$$<br>r = \frac{-Sum}{\epsilon\Delta}(W_{-1}(\frac{Z-1}{e})+1)<br>$$<br>Method 1: 对于敏感度圆外的位置$A,C,D,E$而言，车辆计算单元根据这些查询位置和最近的敏感位置之间的距离进行个性化隐私预算分配，每个位置分配的隐私预算可以表示为<br>$$<br>\epsilon_i = \frac{\lambda d_{i,j}}{\sum_{i=1}^n\sum_{j=1}^N \lambda d_{i,j} \epsilon_1}<br>$$<br>其中，$L_i$表示用户当前的位置，$S_j$表示敏感位置，$\lambda=1$意味着$L_i$选择$S_j$作为它最近的敏感位置。</p><p>Method 2：对于敏感圆的个性化位置隐私保护，我们采用平等的隐私预算分配方法。敏感圆中的位置B的隐私预算可以如下表示，<br>$$<br>\epsilon_B=\frac{\epsilon_1-(\epsilon_A+\epsilon_C+\epsilon_D+\epsilon_E)}{n}-m\times dd<br>$$<br>dd是由用户设置的常数，这意味着敏感圆中隐私预算的大小将以相等差的形式变化。n是敏感圆中的位置数。 对于每次分配，我们使用PSO-SLG算法[7]来平衡隐私和服务质量，以获得最佳的隐私预算εB</p><h2 id="二-非交互式差分隐私的灵敏度分析：边界和高效算法"><a href="#二-非交互式差分隐私的灵敏度分析：边界和高效算法" class="headerlink" title="二 非交互式差分隐私的灵敏度分析：边界和高效算法"></a>二 非交互式差分隐私的灵敏度分析：边界和高效算法</h2><p>Abstract—Differential privacy (DP) has gained significant attention lately as the state of the art in privacy protection. It achieves privacy by adding noise to query answers. We study the problem of privately and accurately answering a set of statistical range queries in batch mode (i.e., under non-interactive DP). The noise magnitude in DP depends directly on the sensitivity of a query set, and calculating sensitivity was proven to be NP-hard. Therefore, efficiently bounding the sensitivity of a given query set is still an open research problem. In this work, we propose upper bounds on sensitivity that are tighter than those in previous work. We also propose a formulation to exactly calculate sensitivity for a set of COUNT queries. However, it is impractical to implement these bounds without sophisticated methods. We therefore introduce methods that build a graph model G based on a query set Q, such that implementing the aforementioned bounds can be achieved by solving two well-known clique problems on G. We make use of the literature in solving these clique problems to realize our bounds efficiently. Experimental results show that for query sets with a few hundred queries, it takes only a few seconds to obtain results.</p><p>定义 （$S_{L_1}(Q)$）: 让$q(D)$表示查询$q$在数据库$D$上的输出。给定查询集$Q$，$Q$的敏感度，表示为$S_{L_1}(Q)$：<br>$$<br>S_{L_1}(Q) = \max_{D,D’}(\sum_{q\in Q}|q(D)-q(D’)|)<br>$$<br>最大团问题（Maximum Clique Problem, MCP）是图论中一个经典的组合优化问题，也是一类NP完全问题。最大团问题又称为最大独立集问题（Maximum Independent Set Problem）。目前，求解MCP问题的算法主要分为两类：确定性算法和启发式算法。确定性算法有回溯法、分支限界法等，启发式算法、蚁群算法、顺序贪婪算法、DLS-MC算法和智能搜索算法等。</p><p>给定无向图$G=(V,E)$，其中$V$是顶点集；$E$是$V$边集。如果$U$属于$V$，且对任意两个顶点$u，v∈U$有$(u,v)∈E$，则称$U$是$G$的完全子图。$G$的完全子图$U$是$G$的一个团当且仅当$U$不包含在$G$的更大的完全子图中。$G$的最大团是指$G$中所含顶点数最多的团。</p><p>如果$U$属于$V$，且对任意$u，v∈U$有$(u,v)$不属于$E$，则称$U$是$G$的空子图。$G$的空子图$U$是$G$的独立集当且仅当$U$不包含在$G$的更大的空子图中。$G$的最大独立集是$G$中所含顶点数最多的独立集。</p><p>对于任一无向图$G=(V,E)$，其补图$G’=(V’,E’)$定义为：$V’=V$，且$(u,v)∈E’$当且仅当$(u,v)∉E$。</p><p>如果$U$是$G$的完全子图，则它也是$G’$的空子图，反之亦然。因此，$G$的团与$G’$的独立集之间存在一一对应的关系。特殊地，$U$是$G$的最大团当且仅当$U$是$G’$的最大独立集。</p><p>这里有两个概念</p><p>Maximum clique problem</p><p>Maximal clique enumeration problem</p><p>上面是最大团问题，下面是极大团枚举问题</p><p><img src="5.png" alt="Q的图模型"></p><p>我们可以得到$MCS(G)= \{Q1,Q2,Q3\}$</p><p>$MCE(G)= \{Q1,Q2,Q3\}.\{Q3,Q4\},\{S\},\{Q5\}$</p><p>引入流行集$Popularity \  set \ of \ a \ record:popSet(r)$,每一个包含$r$的查询响应所构成的子集，即$r$能够影响到的所有查询的子集。</p><p><img src="3.png" alt="流行集"></p><p>可以证明差分隐私的bound可以由流行集来定义：</p><p><img src="6.png" alt="popset_Bound"></p><p>本文的核心思想之一，把找到一个流行集的问题（即找到bound）转化成了找到所生成的图模型中最大团的问题。</p><p>所以差分隐私的bound可以有以下的新的定义：</p><p>（1）$BOUNDING \ S_{L_1} (Q) \ with \ MCS(G)$</p><p><img src="7.png" alt="MCS(G)_Bound"></p><p>不过显而易见的是，一个record r最多影响一个最大团的范围的query，这样的一个bound是远远高估的。所以我们考虑列举Q中所有的团，也就是运用第二个概念极大团枚举。</p><p>（2）$BOUNDING \ S_{L_1 } (Q) \ with \ MCE(G)$</p><p><img src="8.png" alt="MCE(G)_Bound"></p><p>把问题简化成找到最大的两个集团，因为我们是$r\rightarrow r’$，最多是两条记录的改变。</p><p>over</p><h2 id="三-大社会的信任型个性化隐私保护方案"><a href="#三-大社会的信任型个性化隐私保护方案" class="headerlink" title="三  大社会的信任型个性化隐私保护方案"></a>三  大社会的信任型个性化隐私保护方案</h2><p>摘要—在大数据时代，社交网络应用程序的快速发展已成为至关重要的数据源，而大量个人数据的收集却引起了人们对隐私的重大关注。 差异性隐私已成为一种有效的工具，可以在获取有用信息的同时提供强大的隐私保证。 但是，当前大多数提议的解决方案都假定网络中的所有个人都需要统一级别的隐私保护，这排除了个人的个性化要求。 为了解决这个问题，在本文中，我们通过结合信任的概念，提出了一种信任粒度的个性化差异隐私机制，称为TGDP。 具体来说，每当一个用户想要获取另一个用户的个人信息时，建议的机制都会返回一个相应的私人响应，其中为每个人选择的隐私级别取决于他们在网络中的信任值。 与传统方法相比，该方案可以提供一种细粒度的差异隐私保护方法，同时保证了社交网络的实用性。 最后，对该方案进行了分析评估，并在实际数据上进行了实验证明，这反映了其有效性和实用性。</p><p>个性化差分隐私</p><p>定义 (Personalized Differential Privacy)一个随机算法$M$给任一一对相邻数据集$D_1$和$D_2$$\psi-differential  -privacy$，并且对于任一集的输出$\Omega$，$M$满足：<br>$$<br>P_r[M(D_1)\in \Omega]\le e^{\epsilon_{\varphi}(i)}\cdot P_r[M(D_2\in \Omega)]<br>$$<br>其中，$\epsilon_{\varphi}(i)$是用户的隐私需求。</p><p>Problem 1：给定社交网络$G(V,E)$中的两个随机用户$u_i$和$u_j$，设计一种有效的机制$M1$，以基于包括交互频率和拓扑结构在内的多种因素来评估$u_i$对$u_j$的信任值$T(i,j)$的关系。</p><p>Problem 2: 设计一个隐私感知机制$M_2:D\rightarrow \Delta(D)^N$在社交网络上私密的发布用户的隐私数据$d_i\in D$。机制$M_2$应该具有$\epsilon (t_{i,j}-differential privacy)$对数据集$D_i$可以生成可变响应$y_{i,j}$</p><p><img src="3.jpg" alt="3"></p><p>$T(i,j)$需要考虑两个因素：</p><p>1） 交互因素，客观的可信度随用户之间的交互频率而定。$I_{i,j}$表示两个用户节点之间总的交互数。</p><p>2）拓扑关系因子：$d_{i,j}$表示连接节点$i$和$j$的最短距离。$DC_i$用来表示社会图中的度中心性。</p><p>信任值计算</p><p>考虑如下两个因素：</p><p>1）Interpersonal implicit trust人际关系隐含信任</p><p>社交的互动频率$f$和持续时间$d_u$被认为是两个关键的因素，其对可信赖性的贡献可建模为：<br>$$<br>$F(x|f)=\frac{1}{\sigma_F \sqrt{2\pi}}\int^f_{-\infty} e^{-\frac{(x-\mu_F)^2}{2\sigma^2_F}}dx<br>\\D_u(x|d_u)=\frac{1}{\sigma_{D_u} \sqrt{2\pi}}\int^f_{-\infty} e^{-\frac{(x-\mu_{D_u})^2}{2\sigma^2_{D_u}}}dx<br>$$<br>其中$\mu_F$和$\mu_{D_u}$分别是交互周期和交互频率的平均值，$\sigma_F$和$\sigma_{D_u}$是标准误差</p><p>隐式信任水平$T_{II}(i,j)$可以度量为：<br>$$<br>T_{II}(i,j) = \omega_1 F+ \omega_2 D_u<br>$$<br>2) 拓扑关系信任：</p><p>社会距离</p><p>度中心  用户的度表示这个用户有多少个朋友<br>$$<br>T_{T,R}(i,j)=\frac{DC_j}{Neigh(i)_{max}}\times \delta^{(1-\frac{1}{d_{i,j}})}<br>$$<br><strong>将信任映射到隐私</strong></p><p>将个人隐式信任和拓扑关系信任合并在一起，有</p><p>$T(i.j)=\alpha T_{II}(i,j)+(1-\alpha)T_{TR}(i,j)$</p><p>在量化用户的信任度之后，隐私保护度也可以做如下计算：</p><p>$\epsilon(t_{i,j})=\frac{t_{i,j}}{t_{i,j}+\sigma}$</p><p>其中$\epsilon$是众所周知的隐私参数控制差分隐私保证的力度。因此，计算相应的查询响应</p><p>$y_i = f(D)+Lap(\frac{S(f)}{\epsilon})$</p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分隐私 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分蛋糕博弈(二)</title>
      <link href="/2020/11/05/envy-freeness/"/>
      <url>/2020/11/05/envy-freeness/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Little-Charity-Guarantees-Almost-Envy-Freeness"><a href="#A-Little-Charity-Guarantees-Almost-Envy-Freeness" class="headerlink" title="A Little  Charity Guarantees Almost Envy-Freeness"></a>A Little  Charity Guarantees Almost Envy-Freeness</h1><p>一点慈善确保无嫉妒</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​    对不可分割的商品进行公平的分割是经过了充分的研究的问题。这个问题的目的是将m个商品以“公平”的方式分给n个代理人，其中每一个代理人对每个商品子集有子集的估值。我们假设是一般估值</p><p>​    无嫉妒是公平中最广泛研究的概念。然而，无嫉妒分配在商品不可分割的时候并不是总是存在的。我们在这里考虑的公平的概念是“无嫉妒至上（envy-freeness up to any good）”,从其他代理商的包裹中取出任一束后，没有代理人会嫉妒其他的代理人。不知道这种分配是否总是存在。</p><p>​    商品集划分成n+1个子集($X_1,…,X_n,P$)，其中$i\in[n]$，$X_i$是分配给代理人$i$的束，集合$P$是未分配的（或者说捐赠给慈善机构的）如此，我们有：</p><p>$\bullet$ 无嫉妒至上</p><p>$\bullet$ 没有代理人认为集合$P$高于他自己的束，并且</p><p>$\bullet$ 少于n的商品用于慈善，$.i.e,|P|&lt;n(通常 m \ge n)$</p><p>我们的证明是建设性的，引导了使用伪多项式时间算法来找到这种分配。当代理人具有加性估值并且$|P|$很大（当$|P|$接近$n$的时候），我们的分配同样能有很好的最大最小份额（MMS）保证。此外，我们算法的一个较小变量还显示了存在一个4/7的逐组最大最小化的份额（GMMS，groupwise maximin share）:这是一个比MMS更强的公平概念。改善了以知的近似GMMS分配的当前最佳的1/2界限分割。 </p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​    在竞争的代理人之间公平分割（fair division）物品是经济学和计算机中的基础问题。商品集$M$有$m$个物品，目标是以公平的方式在$n$个代理人之间分配商品。分配指的是将$m$划分为不相交的子集($X_1,…,X_n$)。其中$X_i$是给代理人$i$的商品集。那么什么时候一个分配可以被认为是“公平”呢？关于公平最深入研究的概念之一是“无嫉妒”。每一个代理人都有一个与每一个$M$的子集相关联的值并且如果代理人$i$认为$X_j$的价值比$X_i$高的时候，代理人$i$会嫉妒$j$。如果在一个分配中，没有人嫉妒其他的人的话，就被认为是无嫉妒的。一个无嫉妒的分割可以被认为是$n$个代理人之间对商品集$M$的公平且理想的分配。因为没有一个代理人是嫉妒另一个代理的。这种分配机制可以追溯到圣经。</p><p>​    不同于可分割的土地，在我们设定中的商品是可以不分割的并且无需无嫉妒的分配给定商品集。考虑下面的简单示例，其中有两个代理人并且他们都希望拥有的单个商品：其中的一个代理人收到该商品，而另一个代理人嫉妒他。因为不需要考虑无嫉妒分配，因此考虑了一些放宽的措施（Relaxation）。</p><p>​    <strong>Relaxation</strong>放宽：Budish引入了$EF1$的概念：这是一种商品分配，它是单一商品的无嫉妒性（envy-free to one good） 在$EF1$分配中，代理人$i$ 可能会嫉妒代理人$j$，但是这种嫉妒在某些商品从$X_j$中移除的时候会消失。注意，实际上并没有真正的从$X_j$中移除任何商品：这只是一种评估$i$价值$X_j$比$X_i$多多少的一种方法。也就是说，如果$i$认为 $X_j$的价值比$X_i$多，那么会存在一些$g\in X_j$使得$i$价值$X_i$至少和$X_j\setminus {g}$ (差集)一样多。回到两个代理人和单个商品的例子，一个代理人收到此物品的分配叫做$EF1$。能够知道$EF1$是总是存在的；这样的分配可以有效的计算出来。</p><p>​    Caragiannis等<sup>[13]</sup>。 引入了一种叫做$EFX$的无嫉妒概念，它比$EF1$强。 $EFX$分配是“任一商品无嫉妒的分配”。在$EFX$分配中，代理$i$可能会嫉妒代理$j$，但是，一旦从$X_j$中删除了任一商品，这种嫉妒就会消失。因此，每个$EFX$分配也都是 $EF1$，但不是每个$EF1$分配都是$EFX$。</p><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>Agent1</td><td>1</td><td>1</td><td>2</td></tr><tr><td>Agent2</td><td>1</td><td>1</td><td>2</td></tr></tbody></table><p>​    考虑以上的两个例子，有$a,b,c$三个商品，两个具有加性估值的代理人（集$S\in M$的值等于$S$中商品的价值之和）。两个代理人都认为$c$的价值是$a$或$b$ 的两倍。代理人1获得$\{a\}$，代理人2获得$\{b,c\}$ 的这种分配是$EF1$但不是$EFX$。当代理人1获得$\{a,b\}$，代理人2获得$\{c\}$ 的这种分配是$EFX$。实际上，后一种分配似乎比前一种分配更加的公平。可以说，$EFX$是对无嫉妒的不可分割事务的最好公平。尽管已知$EF1$分配始终存在，但是$EFX$分配是否存在的问题仍然是一个未解决的问题。</p><p>​     Plaut和Roughgarden表明，$EFX$分配始终存在（i）只有两个代理人时，或（ii）所有的代理人有同样估值。而且，在[26]中表明，即使在只有两个具有相同子模块估值函数的限制中，也可能需要成倍地指数查询许多值来确定$EFX$。直到最近的研究表明，即便是仅有三个具有加性估值的代理人的情况下，$EFX$分配是是恒存在的。Chaudhury等人最近对这个问题给出了肯定的答案。[15]表明仅有三个具有加性估值的代理人的情况下，$EFX$分配是是恒存在的。有人在[26]中指出：“我们怀疑至少对于一般估值来说，存在不存在$EFX$分配的情况”。</p><p><strong>A relaxation of EFX</strong>.   最近，Caragiannis等人。 [12]介绍了一种更宽松的$EFX$概念，称为$EFX-with-charity$。 这是$EFX$的部分分配，即不需要在代理人之间分配整个商品。 因此，有些商品可能会被分配出去，并假定这些未分配的商品是捐赠给慈善机构的。 有一个非常简单的分配，即$EFX-with-charity$，其中没有将商品分配给任何代理人，因此所有商品都捐赠给了慈善机构。显然，这不是一种有趣的分配，有人会寻求具有更好保证的分配。这种分配在[12]中有表明。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>​    设置$X^<em> = &lt;X^</em>_1,…,X^<em>_n&gt;$为整个商品集的最佳纳什社会福利分配（该分配最大化$\begin{matrix}\prod_{i=1}^N v_i(X_i^</em>) \end{matrix}$，其中$v_i$是代理人$i$的估值函数）。在[12]中表明，总是存在有$EFX-with-charity$的分配$X=(X_1,…,X_n)$，其中每个代理人都至少收到其$X^<em>$的分配值的一半。有趣的是，[12]中表明，对于所有的$i$有$X_i\in X_i^</em>$。不幸的是，未分配的商品的数量或任何代理人给慈善机构捐赠的商品的价值是没有上限的。</p><p>​    我们认为这些是重要的问题。理想的分配是使用$EFX$机制分配所有的商品。因此我们希望能够保证将大量商品分配给代理人。此外，因为$EFX$分配保证了无嫉妒，一旦任何物品从另外的代理人的集中移除，我们本着同样的精神，去寻找一种$EFX$（局部）分配，其中没有人嫉妒未分配的商品集。文献[12]中的分配不能保证外分配的商品集的数量，也不能保证任何代理人对这组未分配商品的重视程度是否超过其自己的商品束。就是说，我们寻求其分配给慈善机构的范围有界限的$EFX-with-charity$分配。即捐赠给慈善机构的商品集的大小和价值的界限。</p><h3 id="1-1-我们的结果"><a href="#1-1-我们的结果" class="headerlink" title="1.1 我们的结果"></a>1.1 我们的结果</h3><p>设置$N=[n]$为代理人集。每一个代理人$i\in [n]$都有一个估值函数$v_i:2^M \rightarrow R_\ge 0$，其中$M$是$m$个商品的商品集。</p><h4 id="1-1-1-一般估值"><a href="#1-1-1-一般估值" class="headerlink" title="1.1.1 一般估值"></a>1.1.1 一般估值</h4><p>我们展示了一般估值函数的主要存在结果，即我们对任何估值函数$v_i$所做的唯一假设是</p><p>（i）规范化，即$v_i(\empty)=0$（ii）单调性，即$S\in T$表明$v_i(S)\le v_i(T)$。</p><p>相反的是，[12]中的$EFX-with-charity$分配仅适用于加性估值，即对于任何$S\in M$和$i\in [n]$，我们有$v_i(S)=\begin{matrix}\sum_{g\in S} v_i(\{g\}) \end{matrix}$。</p><p>$\bullet$我们表明总存在一个分配$X = &lt;X_1,…,X_n&gt;$满足以下的属性：</p><p>1.$X$是$EFX$，$i.e.$对于任意两个代理人$i,j:v_i(X_i)\ge v_i(X_j\setminus\{g\})$，任意$g\in X_j$；</p><p>2.对所有的代理人$i$有$v_i(X_i)\ge v_i(P)$，其中$P=M \setminus \begin{matrix} \bigcup_{i=1}^n X_i \end{matrix}$是未分配商品集；</p><p>3.$|P|&lt;n$（$n$是代理人的数量）。</p><p>​    我们的结果表明，在n个代理人中，如果只有一个没有偏好的代理人（例如，我们对所有的$S\subseteq M$有$v_i(S)=0$），则对于一般估值而言，总存在完整的$EFX$分配：在代理人集$N\setminus\{i\}$中，找到满足上述所有三个属性的$EFX$分配。注意代理集$N\setminus\{i\}$中的分配是$EFX$。我们现在分配$P$（未分配的商品的集）给代理人$i$。观察的到，代理人$i$不嫉妒任何人，因为$i$对所有的商品集有着相同的价值函数，并且没有人嫉妒$i$，因为没有人嫉妒$P$（通过条件2）。因此我们有一个完成的$EFX$分配！</p><p>​    我们的证明是建设性的。我们从没有商品分配给代理人开始，并通过最多$nmV/\Delta$应用的三个简单更新规则来得到所要求的分配，其中$n$是代理人的数量，$m$是商品的数量，$V=max_iv_i(M)$是任何代理人的最大价值，$\Delta=min_imin\{|v_i(T)-v_i(S)|:S,T\subseteq M 且 v_i(S)\neq v_i(T)\}$是不同估值之中最小的差值。</p><p>​    更新规则使用最小嫉妒子集预言机：给定$S\subseteq M$，使得有一个代理人对S的重视程度高于其自己的束。找到一个包含式最小子集$Z\subseteq S$。从而使得一个代理人认为$Z$的价值比自己的束高。这个预言机可以通过最多nm值查询的简单算法来实现。</p><p>$\bullet$对于一般估值，使用$poly(n,m,V,1/\Delta)$值查询，即在多项式时间内，计算具有1-3属性的$EFX$分配。</p><h4 id="1-1-2-相同的估值"><a href="#1-1-2-相同的估值" class="headerlink" title="1.1.2 相同的估值"></a>1.1.2 相同的估值</h4><p>代理人都有相同的估值函数时，我们的分配是完全的。也就是说，$|P|=0$。这是对相同（一般）估值存在完整$EFX$分配的替代证明。</p><h4 id="1-1-3-加性估值"><a href="#1-1-3-加性估值" class="headerlink" title="1.1.3 加性估值"></a>1.1.3 加性估值</h4><p>最容易理解的估值函数类别是加性估值集。我们考虑所有的代理人都有加性估值的情况，并证明我们的分配或者我们分配中的很小一部分可以保证公平的其他几个概念。</p><p><strong>确保高纳什社会福利</strong>  我们表明，修改算法的开始步骤可以确保满足上述属性1-3的分配$X$也具有较高的纳什社会福利。也就是说，$v_i(X_i)\ge \frac{1}{2}\cdot v_i(X_i^<em>)$，其中$X^</em> = &lt;X^<em>_1,…,X^</em>_n&gt;$是纳什社会福利的最佳分配。在这里我们使用[12]中计算的分配在我们开始的步骤作为黑匣子，因此我们的结果可以视为[12]中结果的扩展。</p><p><strong>未分配商品数量和MMS担保</strong>  例外一个有趣且深入研究的公平概念是最大最小分享（maximin share）。假设代理人$i$知道，就她的估值而言，她将获得最差的束，所以必须将$M$划分为$n$个束或者集合。然后，$i$选择$M$的一个划分，最大化最差束的价值。最差束的价值是代理人$i$的最大最小化分享。这里有一个很重要的问题：是否总是存在$M$的分配，每个代理人都能够获得至少等于其maximin share份额的束呢？</p><p>​    正式的，设置$N$和$M$分别为$n$个代理人的集和$m$个商品的集。我们定义一个代理人的maximin share如下：（在这里$\chi$是所有完整分配的集合）<br>$$<br>MMS_i(n,M)= \begin{matrix}\max_{&lt;X_1,…,X_n&gt;\in\chi} \min_{j\in v_i} (X_j) \end{matrix}<br>$$<br>  目标是确定$M$的分配,$&lt;X_1,…,X_n&gt;$以便对于每个$i$我们都有$v_i(X_i)\ge MMS_i(n,M)$。这个问题首先由Budish提出[11]。Procaccia和Wang展示了如此的分配不需要存在，即便在只有三个代理人的受限环境下。此后，研究了近似MMS分配[27,20,22,21]，并且存在多项式时间算法来确定分配，其中对于所有$i$，代理人$i$至少获得一束价值$\alpha \cdot MMS_i(n,M)$；当前对$\alpha$最好的保证是$3/4-\epsilon$（对于任意$\epsilon &gt; 0$）并且最近被改善到$3/4$，通过Garg和Taki[21]。</p><p>​    Amanatidis等[1]表明，任何完整的$EFX$分配也是$4/7-MMS$分配。我们表明，当未分配的商品的数量很大时，我们的分配有望提供更好的$MMS$保证。让$X = &lt;X_1,…,X_n&gt;$是如上面的属性1-3所述的我们的分配，$P$是商品的集合。对于任意的代理人$i \in [n]$，我们有：<br>$$<br>v_i(X_i)\ge \frac{1}{2-|P|/n}MMS_i(n,M)<br>$$<br>因此，未分配的商品数量越多，我们在$MMS$上获得的保证就越好。极值是$|P|=0$和$|P|=n-1$。当$|P|=0$时，我们有完整的$EFX$分配，当$|P|=n-1$时，我们有一个几乎是$MMS$的分配：对于所有$i$,$v_i(X_i)\ge (1-1/n)\cdot MMS_i(n,M)$</p><p><strong>改进的Groupwise MMS保证</strong>  Barman等[6]最近引入了一种公平的概念，称为群最大最小份额(GMMS)，它比MMS更强大。如果满足对于每个子组的代理人，有一组商品的集合分配给他们，则这个分配被称为GMMS。正式地，一个完整的分配$X = &lt;X_1,…,X_n&gt;$是$\alpha - GMMS$，如果对于任意的$N’ \subseteq N$，我们有$v_i(X_i)\ge \alpha \cdot MMS_i(n’,\bigcup_{i\in N’}X_i)$，其中$n’=|N’|$。每一个GMMS分配，例如$\alpha=1$，也是一个完整的$EFX$分配。</p><p>​    众所周知[6]GMMS严格概括了MMS。特别是，在[6]中表明，GMMS分配排除了一些非常不令人满意的具有MMS保证的分配。例如，考虑一个示例，该示例具有n个加性估值的代理人，具有$n-1$商品的商品集$M$，并且每一个代理人对每一个商品有着估值。因为商品的数量比代理人的数量少，我们对每个代理人$i$有$MMS_i(n,M)$。所以任何的分配都有MMS保证。不难看出，具有GMMS保证的唯一分配只有一个，其中$n-1$个代理人获得唯一一个商品，一个代理人没有任何商品。自然而然地，与MMS相比，近似GMMS是一个更困难的问题。尽管$\frac{3}{4}-MMS$分配总是存在，但已知最大的$\alpha-GMMS$分配的$\alpha$值是1/2。我们扩展了Amanatidis等人的结果，使MMS如下：</p><p>$\bullet$$\frac{4}{7}-GMMS$分配总是存在并且可以在多项式时间内计算</p><p>特别的，我们表明修改后的算法的最后一步会导致完整分配为$\frac{4}{7}-GMMS$ 。最近和独立地，Amanatidis等人。  [3]显示了相同的近似值。</p><h3 id="1-2-我们的技术"><a href="#1-2-我们的技术" class="headerlink" title="1.2 我们的技术"></a>1.2 我们的技术</h3><p>现在，我们概述用于查找$EFX$分配的主要思想。我们首先回顾一下Lipton等人[25]的算法找到$EF1$分配。他们使用了嫉妒图的概念：每一个顶点都对应于一个代理人，并且边$(i,j)$代表$i$嫉妒$j$。保持不变的是，嫉妒图是DAG:一个回路对应于一个嫉妒回路，并且通过沿着一个回路交换束。每一位代理人变得更好并且嫉妒边的数量没有增加。更加准确地是，如果$i_o\rightarrow i_1\rightarrow i_2\rightarrow …\rightarrow i_{i-1}\rightarrow i_o$是嫉妒图中的一个回路。然后将$X_{i_{j+1}}$重新分配给代理人$i_j$,$0\leq j\leq \ell$(索引将以模数$\ell$ 读取)将会提高权重每个代理人的估值。同样，如果存在从一条边从$s$到$i_{k}$，$s$不属于回路的一部分。那么我们在沿着回路交换束之后，该边从$s$指向$i_{k+1}$.因此，途中嫉妒边的数量没有增加，并且在回路中代理人的价值也会上升，因此可以消除回路。</p><p>​    [25]中的算法循环运行，并且始终保持分配是$EF1$。在每个回合开始时，标识一个不嫉妒的代理$s$（这是DAG的一个源顶点），并将没有分配的商品g分配给s。新分配也是$EF1$，因为没有人会嫉妒移除商品g后的s束。</p><p><strong>重新分配操作</strong>  现在，我们重点介绍$EF1$分配和$EFX$分配之间的关键区别。 根据Lipton等人的算法。  [25]，很明显，给定一组商品$M_0$的EF1分配，只需将$M_1$的商品逐一添加到存在的束中并且巧妙的改变所有者（如果有必要的话），对于任何$M_0 \bigcup M_1$，就可以确定EF1分配。 直观地讲，我们无需剪切或合并任何$EF1$分配中形成的束。 我们可以将未分配的商品适当地附加到当前束中。</p><p>对于$EFX$，上述策略与实际情况想去甚远，考虑以下所示的示例，其中三个代理商具有加性估值，四个产品$a,b,c,d$。</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">d</th></tr></thead><tbody><tr><td align="center">Agent 1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">Agent 2</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">Agent 3</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">2</td></tr></tbody></table><p>对于前三种商品的$EFX$分配必须给这三个代理人中的每一个都准确地给出a，b，c中的一个。 但是，所有四种商品的$EFX$分配必须将单例集{d}分配给某个代理（例如，agent 1），或者例如{a}分配给agent 2，{b，c}分配给agent 3。因此，需要对分配进行切割和合并。 如果有很多代理人（每个代理人都有自己的估值），则很难进行分拆合并操作。 在这里，我们实现了如下的全局重新分配操作。</p><p>改善社会福利  假设我们有$EFX$分配$X = &lt;X_1,…,X_n&gt;$在某些子集$M_0\sub M$上。我们现在想要添加一个商品$g\in M\setminus M_0$。但是我们将无法在$M_o\cup \{g\}$上保证$EFX$ 分配。我们将确保情况(i)或情况（ii）发生</p><p>(i) 我们有一个在子集$M_o\cup \{g\}$上的$EFX$分配$X’ = &lt;X’_1,…,X’_n&gt;$使得对于所有的$i$有$v_i(X’_i)\ge v_i(X_i)$并且至少存在一个代理人$j$有$v_j(X’_j) &gt; v_j(X_j)$。因此$\begin{matrix}\sum_{i\in [n]} v_i(X’_i) &gt; \sum_{i\in [n]} v_i(X_i) \end{matrix}$；换句话说，严格的改善了社会福利。</p><p>(ii)我们有一个在$M_o\cup \{g\}$上的$EFX$分配并且社会福利没有增加。</p><p>因此，在我们算法的每个步骤中，要么增加社会福利，要么增加分配的商品数量而不降低社会福利，因此我们总是在进步。这类似于Plaut和Roughgarden [26]使用的方法，当代理商具有次加性估值时，它保证存在$\frac{1}{2}-EFX$。 现在，我们概述如何确保情况（i）和（ii）之一必须发生。</p><p>为了简化说明，我们假定与我们的起始$EFX$分配$X$对应的嫉妒图只有一个来源$s$。 将$g$添加到$s$的束中：如果没有人嫉妒$s$的任何商品，那么我们的情况就很容易了，因为我们在$M_o\cup \{g\}$上有$EFX$分配。 在这种情况下，我们“使”嫉妒图“循环”（如果创建了循环）并继续。请注意，沿着嫉妒图的循环交换束可以增加社会福利。</p><p><strong>最嫉妒的代理人</strong>  现在假设在将$g$分配给$s$之后，有一个或多个代理人嫉妒$s$的任何商品。 为了解决这个问题，我们引入了最嫉妒代理人的概念。 让$i$成为一个嫉妒$s$的所有东西的代理人，所以对于某些$S’\sub X_s\cup \{g\}$有$v_i(X_i)&lt;v_i(S’)$。令$S_i$为$X_s\cup \{g\}$的任何包含式最小子集，使得$v_i(X_i)&lt;v_i(S_i)$（打破任意关系）。所以对任何$T\sub S_i$，我们有$v_i(X_i)\ge v_i(T)$。<br> $\bullet$ 代理人$i$使得对于某些$S_i\sub X_s \cup \{g\}$有$v_i(X_i)&lt;v_i(S_i)$，没有任何代理人嫉妒$S_i$的严格子集，将会称为在 $X_s\cup \{g\}$上最嫉妒的代理人（break ties arbitrarily）</p><p>让$t$成为$X_s\cup \{g\}$上的最嫉妒代理人。关键的观察结果是，没有任何代理人嫉妒$S_t$的任何商品。否则的话，他将与$S_t\sub X_s\cup \{g\}$成为一个包含书最小嫉妒子集相矛盾，即，任何代理人都不嫉妒$S_t$的合适子集。回想一下s是唯一来源的假设，所以在这嫉妒图中有一个路径$s\rightarrow i_1\rightarrow i_2\rightarrow …\rightarrow i_{k-1}\rightarrow t$。我们沿着这条路径向左移动束：所以$s$获得了$i_1$的束，并且对于$1\le r\le k-1$：$i_r$获得$i_{r+1}$的束（其中$i_k=t$)，最终$t$获得$S_t$。$X_s\cup \{g\}$中的商品被仍回到未分配的商品池中。</p><p>可以观察到，与分配$X$相比，此路径上的每个代理人现在严格来说都比其他代理人更好。 此外，根据$S_t$的定义，没有任何代理人嫉妒任何其他代理人。 因此，我们有一个期望的$EFX$分配$X’$。 当有多个来源(Source)时，只要有足够的未分配商品，我们就可以采用这种技术。 特别是，未分配商品的数量必须至少等于嫉妒图中的来源数量。 我们将在第2节中对此进行详细描述。<br>   我们想将上述方法与其他$EFX$算法进行对比[26，12]。  Plaut和Roughgarden [26]的$1/2-EFX$算法或者将g（新商品）与现有的束合并，或者将单例集$\{g\}$分配给代理。  Caragiannis等人的$EFX-with-charity$算法。  [12]采用最大纳什社会福利分配作为输入，然后从实例中永久删除一些商品。 我们认为“最嫉妒的代理人”这一概念是一种自然的方式，可以打破束以保持嫉妒的自由，这是我们工作的创新贡献之一。</p><p><strong>我们的其他结果</strong> 关于我们具有近似$MMS$保证的结果，如果$EFX$分配中未分配商品的数量很大，那么源点的数量也必须很大：这些是令人嫉妒的代理商。 而且，没有代理人嫉妒未分配的商品集。<br>   现在假设$|P|  = n-1$。 这意味着每个代理人都是来源。 因此，没有代理人嫉妒任何其他代理人的束以及未分配商品的集合。 因此，对于每个代理$i$，我们有：<br>$$<br>\begin{split}<br>v_i(X_i)\ge \frac{v_i(M)}{n+1} \ge (1+1/n)^{-1}\cdot \frac{v_i(M)}{n}\<br>     \qquad  \ge  (1-1/n)^{-1}\cdot MMS_i(n,M)<br>\end{split}<br>$$<br>其中，$v_i(M)/n\ge MMS_i(n,M)$对附加价值具有约束。我们在第三节中展示了近似$MMS$分配的结果和近似$GMMS$分配的改进边界。</p>]]></content>
      
      
      <categories>
          
          <category> game-theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> envy-freeness </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 免嫉妒分割 </tag>
            
            <tag> 论文翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分蛋糕博弈（一）</title>
      <link href="/2020/11/04/game-theory/"/>
      <url>/2020/11/04/game-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="分蛋糕博弈（一）"><a href="#分蛋糕博弈（一）" class="headerlink" title="分蛋糕博弈（一）"></a>分蛋糕博弈（一）</h1><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>有一家外企招聘员工时出了一道面试题：要求应聘者把一盒蛋糕切成了八份，分给八个人，但是蛋糕盒里还必须留一份。</p><p>解析：最简单直接的方法，肯定是均分，可是我们能够确保其他人认可你的均分的结果嘛？ 最可能实现一半对一半的公平分配的方案，是A切蛋糕，让B先选。 </p><p>这种方案很难保证公平，因为双方都不会愿意成为切蛋糕的一方。虽然双方都希望对方切、自己挑，但是僵持的时间不会一直维持，因为这样所带来的时间开销，会导致得不偿失，出现收益缩水的现象。</p><p>在公平分割（fair division）问题中，有一个根本的公平原则叫做“均衡分割”（Proportional division）。如果n个人分蛋糕，则每个人都认为自己得到了整个蛋糕至少1/n的价值。 </p><h2 id="“你来分我来选”"><a href="#“你来分我来选”" class="headerlink" title="“你来分我来选”"></a>“你来分我来选”</h2><p>A，B先分，A来切，B来选</p><p>然后，A和B把手中的蛋糕分成三份，C从每个人手中取走一份，那么A、B、C都有两份。</p><p>A、B、C再将自己手中的蛋糕分成四份，让第四个人D从三人手中各挑选一份。</p><p>重复上述的过程，直到最后一个人选完自己的蛋糕。</p><p>前提：只要每个人在切蛋糕时能够做到均分，无论哪块被挑走，他都不会吃亏；保证每个人手中的蛋糕在自己看来都是不小于蛋糕总价值1/n的（PS. 这样做蛋糕会被分的乱七八糟，不过，whatever…）</p><h2 id="“最后削减人算法”"><a href="#“最后削减人算法”" class="headerlink" title="“最后削减人算法”"></a>“最后削减人算法”</h2><p>总人数n。</p><p>首先A从蛋糕中切出他认为的1/n，然后传递给B，B可以选择直接把这块蛋糕递交给C，也可以选择从中切除一小块（即修剪），然后移交给下一个人。</p><p>规定：最后一个对蛋糕进行“修剪”的人将获得这块蛋糕，其余的n-1人从头开始重复这个流程。</p><p>结果：每进行一个loop，都会有一个人拿到了令他满意的utility，直到所有人得到蛋糕。并且保证了每个人手中的蛋糕是整个蛋糕价值的1/n。</p><p>不过，以上两种方法并非完全公平，对于分蛋糕的人来说，两块蛋糕的价值均等，但是对于选蛋糕的人来说，两块蛋糕的价值是有差异的，因此，选蛋糕的人往往能够获得大于1/2的价值。</p><p><strong>不同人对蛋糕的价值的评判标准不同</strong></p><h3 id="“免嫉妒分割（envy-free-division）”"><a href="#“免嫉妒分割（envy-free-division）”" class="headerlink" title="“免嫉妒分割（envy-free division）”"></a>“免嫉妒分割（envy-free division）”</h3><p>每个人都认为别人的蛋糕没有我手里的好</p><p>1960年，John Selfridge和John Convey各自独立地分析了人数为3的情况，构造除了第一个满足免嫉妒条件的三人分割方案。这种分割方案被称为“Selfridge-Convey算法”。</p><p>首先，A 把蛋糕分成三等份（当然是按照自己的看法来分的，后面提到的切分、选取也都是这样）。如果 B 认为这三块蛋糕中较大的两块是一样大的，那么按照 C 、 B 、 A 的顺序依次选取蛋糕，问题就解决了。麻烦就麻烦在 B 认为较大的两块蛋糕不一样大的情况。此时，B 就把最大的那块蛋糕的其中一小部分切下来，让剩余的部分和第二大的蛋糕一样大。被切除的部分暂时扔在一旁，在第二轮分割时再来处理。接下来，按照 C 、 B 、 A 的顺序依次选蛋糕，但有一个限制：如果 C 没有选那块被修剪过的蛋糕，B 就必须选它。<br>  这样，三人就各分得了一块蛋糕。由于 A 是切蛋糕的人，对于他来说拿到哪一块都一样，因此 A 不会嫉妒别人。由于 B 选取的是两个较大块中的一个，因此 B 也不会嫉妒别人。由于 C 是第一个选蛋糕的，显然他也不会嫉妒别人。因此，就目前来说，三个人之间是不会有嫉妒发生的。<br>  但是，还有一小块被切除的部分没分完，因此分割流程进入第二轮。<br>  在 B 和 C 之间，一定有一个人选择了那块被修剪过的蛋糕。不妨把这个人重新记作 X ，另一个人就记作 Y 。让 Y 把最后那一小块分成三等份，按照 X 、 A 、 Y 的顺序依次挑选蛋糕，结束第二轮流程。这一轮结束后，每个人都又得到了一小块蛋糕。由于 X 是第一个选蛋糕的人， X 显然不会嫉妒别人；由于 Y 是分蛋糕的人， Y 也不会嫉妒别人。由于 A 比 Y 先选， A 不会嫉妒 Y 。最后，A 也是不会嫉妒 X 的，因为即使 X 拥有了第二轮中的全部蛋糕，X 手里的蛋糕加起来也只是第一轮开始时 A 等分出来的其中一块蛋糕，这是不可能超过 A 的。这就说明了，三个人之间仍然不会有嫉妒发生，Selfridge-Conway 算法的确满足免嫉妒条件。</p><p>  不过，Selfridge-Conway 算法只能在三人分蛋糕时使用，并不能扩展到人数更多的情况。对于人数更多的情况，免嫉妒分割问题更加困难，目前数学家们还没有找到一个比较可行的方案。正如数学家 Sol Garfunkel 所说，分蛋糕问题是 20 世纪数学研究中最重要的问题之一。直到现在，也还有一大群数学家正投身于分蛋糕问题之中，研究包括免嫉妒性在内的各种公平条件，致力于构造新的公平分割方案。</p>]]></content>
      
      
      <categories>
          
          <category> game-theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> envy-freeness </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 免嫉妒分割 </tag>
            
            <tag> game-theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇杂谈</title>
      <link href="/2020/11/03/first-article/"/>
      <url>/2020/11/03/first-article/</url>
      
        <content type="html"><![CDATA[<h1 id="hello-我的朋友们，欢迎来到我的blog"><a href="#hello-我的朋友们，欢迎来到我的blog" class="headerlink" title="hello,我的朋友们，欢迎来到我的blog"></a>hello,我的朋友们，欢迎来到我的blog</h1><p>这是写的第一个博客，以后我会把我所学到的，所看到的东西记录在这个里面，不知道这场征途会有多远。</p><p><img src="favicon.jpg" alt="favicon"></p>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
